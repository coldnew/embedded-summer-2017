#+TITLE: 2017 年暑期系統軟體課程：台北場次 - coldnew's 筆記
#+DATE: <2017-07-11 Tue 11:01>
#+AUTHOR: coldnew
#+EMAIL: coldnew.tw@gmail.com
#+OPTIONS: ^:nil -:nil \n:t ^:nil num:nil LaTeX:dvipng

#+SETUPFILE: .theme.org

# Badge
[[https://circleci.com/gh/coldnew/embedded-summer-2017][https://circleci.com/gh/coldnew/embedded-summer-2017.svg?style=svg]]


* 課程資訊

  連結: https://hackmd.io/s/BJRtkreHW

* 操作說明

  這篇文章是透過 [[https://orgmode.org][org-mode]] 以及 [[https://github.com/fniessen/org-html-themes][org-html-themes]] 製作出來，可以使用的快捷鍵資訊如下:

  | 快捷鍵     | 用途                 |   | 快捷鍵 | 用途                         |
  |------------+----------------------+---+--------+------------------------------|
  | =?= 或 =h= | 進入到 *dashboard*   |   | =-=    | 收起所有項目                 |
  | =n=        | 移動到 *下一個* 標題 |   | =+=    | 展開所有項目                 |
  | =p=        | 移動到 *前一個* 標題 |   | =r=    | 移動到下一個在清單的工作項目 |
  | =b=        | 向上滾動             |   | =R=    | 移動到前一個在清單的工作項目 |
  | =<=        | 向上滾動到最上面     |   | =q=    | 離開清單列表                 |
  | =>=        | 向下滾動到最下面     |   | =g=    | 重新載入頁面                 |

* TODO 課前測驗題

  從下方至少選 3 題來作答，不僅要提供程式碼，也該描述思路。作答方式為建立「新的」HackMD 頁面，在「標題」提及自己的姓名或可資識別的代號，內文則應標註原題號，如 Q1:，隨後將新建的 HackMD 連結貼入報名表格，課程工作人員會逐一通知。

    參考: [[https://hackmd.io/s/Bk-1zqIte][HackMD 教學和作業原則]]
    示範: [[https://github.com/coldnew/2015-embedded-summber-note][coldnew]]

** TODO Q1

   考慮以下 C99 程式，解釋其具體作用，並用 for/while 迴圈改寫，隨後提供 uint16_t 的版本。在什麼場合會用到下方的程式碼？

   #+BEGIN_SRC C
     #include <stdint.h>
     uint32_t func(uint32_t x) {
	 uint32_t n = x;
	 n = ((n & 0xffff0000) >> 16) | ((n & 0x0000ffff) << 16);
	 n = ((n & 0xff00ff00) >>  8) | ((n & 0x00ff00ff) <<  8);
	 n = ((n & 0xf0f0f0f0) >>  4) | ((n & 0x0f0f0f0f) <<  4);
	 n = ((n & 0xcccccccc) >>  2) | ((n & 0x33333333) <<  2);
	 n = ((n & 0xaaaaaaaa) >>  1) | ((n & 0x55555555) <<  1);
	 return n;
     }
   #+END_SRC

*** 想法 & 思考

    一開始看到這樣的題目可能不知道怎樣解，所以我們可以套用個數值 =0x12345678= 進去一行一行的測試:

    #+header: :includes <stdint.h>
    #+BEGIN_SRC C :exports all
	 uint32_t n = 0x12345678;
	 n = ((n & 0xffff0000) >> 16) | ((n & 0x0000ffff) << 16);
	 printf("0x%x\n", n);
    #+END_SRC

    #+RESULTS:
    : 0x56781234

    可以發現到第一行是前後 2byte 進行對換的動作，即 =0xAABBCCDD => 0xCCDDAABB= 。

    讓我們往下看到第二組:

    #+header: :includes <stdint.h>
    #+BEGIN_SRC C :exports all
	 uint32_t n = 0x56781234;
	 n = ((n & 0xff00ff00) >>  8) | ((n & 0x00ff00ff) <<  8);
	 printf("0x%x\n", n);
    #+END_SRC

    #+RESULTS:
    : 0x78563412

    可以注意到這一組命令，會做出 =0xAABBCCDD= => =0xBBAADDCC= 這樣的運作。

    接下來看第三組:

    #+header: :includes <stdint.h>
    #+BEGIN_SRC C :exports all
	 uint32_t n = 0x78563412;
	 n = ((n & 0xf0f0f0f0) >>  4) | ((n & 0x0f0f0f0f) <<  4);
	 printf("0x%x\n", n);
    #+END_SRC

    #+RESULTS:
    : 0x87654321

    #+header: :includes <stdint.h>
    #+BEGIN_SRC C :exports all
	 uint32_t n = 0x78654321;
	 n = ((n & 0xcccccccc) >>  2) | ((n & 0x33333333) <<  2);
	 printf("0x%x\n", n);
    #+END_SRC

    #+RESULTS:
    : 0xd2951c84

*** for/while 迴圈改寫

    先建立函式原型

    #+BEGIN_SRC C
      uint32_t reverse_bits(uint32_t x)
      {
	      /* FIXME: return the reverse_bits result */
      }
    #+END_SRC

    那如何使用迴圈改寫這題呢? 首先我們需要知道要反轉的目標字元數，以題目原型為 =uint32_t= 來看，字元數就是 32, 也就是:

    #+BEGIN_SRC C
      uint32_t bits_num = sizeof(uint32_t) * 8; /* <- 32 */
    #+END_SRC

    接下來需要一個暫存用的變數，我命名為 =reverse_x= (輸入到這函式的變數為 x)

    #+BEGIN_SRC C
      uint32_t reverse_x = 0;
    #+END_SRC

    那要怎樣處理我們的迴圈呢? 我們知道我們要進行反轉的目標字元數是 =32= , 因此這個迴圈要跑 =32= 次，或是套用前面的變數，要跑 =bits_num= 次

    #+BEGIN_SRC C
      for (int i = 0; i < bits_num; i++) {
	      /* FIXME: How to do ? */
      }
    #+END_SRC

    在這個迴圈裡面，我們檢查每一次要被處理的位元，假設他是 =1= 的話，再去更新 =reverse_x= 的內容。(reverse_x 預設是 0)

    更新的方法很簡單，透過 =or= 運算子 =|= 來進行處理，由於我們要做的是字元反轉，因此假如我們 bit[3] 是 1 的話，則

    #+BEGIN_EXAMPLE
      從: 0000 0000 0000 0000 0000 0000 0000 1000  <- bit[3]  = 1
      到: 0001 0000 0000 0000 0000 0000 0000 0000  <- bit[28] = 1, bit[32 - 1 - 3]

      從: 0000 0000 0000 0000 0000 1000 0000 0000  <- bit[11]  = 1
      到: 0000 0000 0001 0000 0000 0000 0000 0000  <- bit[20] = 1, bit[32 - 1 - 11]
    #+END_EXAMPLE

    所以可以知道，當要被處理的位元為 =1= 的時候，我們要這樣處理:

    #+BEGIN_SRC C
      for (int i = 0; i < bits_num; i++) {
	      if((x & (1 << i)))
		      reverse_x |= 1 << ((bits_num - 1) - i);
      }
    #+END_SRC

    因此最後的程式如下:

    #+BEGIN_SRC C
      #include <stdint.h>

      uint32_t reverse_bits(uint32_t x)
      {
	      uint32_t bits_num = sizeof(x) * 8;
	      uint32_t reverse_x = 0;
	      for (int i = 0; i < bits_num; i++) {
		      if((x & (1 << i)))
			      reverse_x |= 1 << ((bits_num - 1) - i);
	      }
	      return reverse_x;
      }

      int main(int argc, char *argv[])
      {
	      uint32_t reverse1 = reverse_bits(0x12345678);
	      uint32_t reverse2 = reverse_bits( reverse1 );

	      printf("0x12345678 -> 0x%x -> 0x%x\n", reverse1, reverse2);
	      return 0;
      }
    #+END_SRC

    #+RESULTS:
    : 0x12345678 -> 0x1e6a2c48 -> 0x12345678

*** TODO 改成 uint16_t 的版本

    #+BEGIN_SRC C
      #include <stdint.h>
      uint16_t reverse_bits(uint16_t x) {
	      //uint16_t n = x;
	      uint16_t n = 0x00001234;
	      n = ((n & 0x0000ff00) >> 8) | ((n & 0x000000ff) << 8)
	      return n;
      }
    #+END_SRC

    #+header: :includes <stdint.h>
    #+BEGIN_SRC C :exports all
	 uint32_t n = 0x00001234;

	 n = ((n & 0xffff0000) >> 16) | ((n & 0x0000ffff) << 16);
	 n = ((n & 0xff00ff00) >>  8) | ((n & 0x00ff00ff) <<  8);
	 n = ((n & 0xf0f0f0f0) >>  4) | ((n & 0x0f0f0f0f) <<  4);
	 n = ((n & 0xcccccccc) >>  2) | ((n & 0x33333333) <<  2);
	 n = ((n & 0xaaaaaaaa) >>  1) | ((n & 0x55555555) <<  1);

//	 n = ((n & 0x0000ff00) >> 8) | ((n & 0x000000ff) << 8);
//	 n = ((n & 0x0000f0f0) >> 4) | ((n & 0x00000f0f) << 4);
//	 n = ((n & 0xcccccccc) >>  2) | ((n & 0x33333333) <<  2);
//	 n = ((n & 0xaaaaaaaa) >>  1) | ((n & 0x55555555) <<  1);
	 printf("0x%x\n", n >> 16);
    #+END_SRC

    #+RESULTS:
    : 0x2c48

    0x1234 => 0001 0010 0011 0100
    0x2c48 => 0010 1100 0100 1000

*** 使用到的場合: 加解密運算

    透過本題的程式，可以將 =0x12345678= 轉變成 =0x1e6a2c48= ，而這動作是可以反向的, 我們一樣可以將此函式套用在 =0x1e6a2c48= 從而得到 =0x12345678= 這樣的答案，也就是說將東西丟給這個函式，再把結果丟給這函式，可以得到原本的輸入:

    #+BEGIN_SRC c
      0x12345678 == reverse_bits( reverse_bits(0x12345678) ) /* 兩者相等 */
    #+END_SRC

    利用這種特性，我們可以實作簡單的加解密程式 =rcf.c= ，如下:

    #+BEGIN_SRC C
      #include <stdio.h>
      #include <stdlib.h>
      #include <stdint.h>

      uint32_t reverse_bit(uint32_t x) {
	      x = ((x & 0xffff0000) >> 16) | ((x & 0x0000ffff) << 16);
	      x = ((x & 0xff00ff00) >>  8) | ((x & 0x00ff00ff) <<  8);
	      x = ((x & 0xf0f0f0f0) >>  4) | ((x & 0x0f0f0f0f) <<  4);
	      x = ((x & 0xcccccccc) >>  2) | ((x & 0x33333333) <<  2);
	      x = ((x & 0xaaaaaaaa) >>  1) | ((x & 0x55555555) <<  1);
	      return x;
      }

      int main(int argc, char *argv[])
      {
	      if (argc < 3) {
		      printf( "\nUsage:"
			      "\t %s input.txt output.txt\n\n"
			      "This is a simple encrypt/decrypt app "
			      "based on reverse_bit algorithm.\n\n"
			      , argv[0]);
		      return 0;
	      }

	      const char *input_path = argv[1];
	      FILE *fin = fopen(input_path, "rb");
	      if (!fin) {
		      fprintf(stderr,
			      "ERROR: failed to open input file %s\n", input_path);
		      exit(-1);
	      }

	      const char *output_path = argv[2];
	      FILE *fout = fopen(output_path, "wb");
	      if (!fout) {
		      fclose(fin);
		      fprintf(stderr,
			      "ERROR: failed to open output file %s\n", output_path);
		      exit(-1);
	      }

	      uint32_t ch;
	      int nread;
	      while((nread = fread(&ch, 1, sizeof(uint32_t), fin)) > 0) {
		      /* if read size less than sizeof(uint32_t), just write it */
		      if (nread < sizeof(uint32_t)) {
			      fwrite(&ch, 1, nread, fout);
		      }
		      else {
			      uint32_t chn = reverse_bit(ch);
			      fwrite(&chn, 1, nread, fout);
		      }
	      }

	      fclose(fin);
	      fclose(fout);
	      return 0;
      }
    #+END_SRC

    這個程式可以使用以下命令進行編譯:

    : gcc rcf.c -o rcf

    那要如何使用呢? 我們可以建立一個名為 =hello.txt= 的文字檔，有以下內容:

    #+BEGIN_SRC text
      hello, this is a test
    #+END_SRC

    接下來使用這隻加密程式產生新的檔案叫做 =hello_enc.txt=

    : ./rcf hello.txt hello_enc.txt

    打開可以看到內容如下: (是不是成功加密了!)

    #+BEGIN_SRC text
      66¦^V.^D4ö^DÎ<96>^V<86>^DÎ<96>Î¦.^Dt
    #+END_SRC

    而這個檔案我們一樣可以透過這隻程式進行解密成 =hello_dec.txt=

    : ./rcf hello_enc.txt hello_dec.txt

    打開 =hello_dec.txt= 看看，內容是不是和原來的一樣 ?

    #+BEGIN_SRC text
      hello, this is a test
    #+END_SRC

*** TODO 使用到的場合: 快速傅利葉轉換
*** 補充說明

    在撰寫這一題的時候，順手寫了一個可以將 =uint32_t= 型別的輸入，以二進制的形式顯示出來的函式，這樣也可以比較方便的測試這一個題目:

    #+BEGIN_SRC C  :exports all
      #include <stdint.h>

      void print_binary(uint32_t x) {
	      unsigned char *p = (unsigned char *) &x;
	      unsigned char byte;

	      for (int i = sizeof(uint32_t) -1; i >= 0; i--) {
		      for (int j = 7; j >= 0; j--) {
			      byte = (p[i] >> j) & 1;
			      printf("%u", byte);
			      if (0 == (j % 4))
				      printf(" ");
		      }
	      }
	      printf("\n");
      }

      int main(int argc, char *argv[]) {
	      print_binary(0x12345678);
	      return 0;
      }
    #+END_SRC

    #+RESULTS:
    : 0001 0010 0011 0100 0101 0110 0111 1000

*** 延伸閱讀

    - [[https://stackoverflow.com/questions/2602823/in-c-c-whats-the-simplest-way-to-reverse-the-order-of-bits-in-a-byte][In C/C++ what's the simplest way to reverse the order of bits in a byte? - Stack Overflow]]

    - [[http://graphics.stanford.edu/~seander/bithacks.html#BitReverseObvious][Bit Twiddling Hacks -  Reverse an N-bit quantity in parallel in 5 * lg(N) operations]]

    - [[http://acm.nudt.edu.cn/~twcourse/BitwiseOperation.html][演算法筆記 - Bitwise Operation]]

    - [[http://eshare.stust.edu.tw/EshareFile/2010_6/2010_6_a78298c9.pdf][一般信號處理，常用快速傅立葉轉換（FFT）來求得信所對應的頻譜]]

    - [[https://ccjou.wordpress.com/2012/05/25/%E5%BF%AB%E9%80%9F%E5%82%85%E7%AB%8B%E8%91%89%E8%BD%89%E6%8F%9B/][快速傅立葉轉換 | 線代啟示錄]]

** TODO Q2

   在 C 程式中，使用遞迴和 bit-wise operator 來實作乘法運算，請參考以下提示:

   - 加法器是用於執行加法的電路元件，通常由 AND 閘、OR 閘 和 XOR 閘構成

     + 也可用加法器實作減法，只要將減數轉成二補數，並注意溢位即可

   - 半加器：將兩個一位二進位數相加 (input: A, B) (output: S, C)

     [[file:images/HRN0c1D.png]]

   - 全加器：將兩個一位二進位數相加 (input: A, B, Cin) (output: S, Cout)

     [[file:images/cypKq1H.png]]

   - 波紋進位加法器：使用多個一位全加器構成 N 位加法器

     [[file:images/X5fQcYn.png]]

   - 半加器可用以下 C 程式來實作:

     #+BEGIN_SRC c
       uint32_t half_add(uint32_t a, uint32_t b) {
	   if (b == 0) return a;
	   uint32_t sum = a ^ b;             /* 相加但不進位 */
	   uint32_t carry = (a & b) << 1;    /* 進位但不相加 */
	   return half_add(sum, carry);
       }
     #+END_SRC
** TODO Q3

   思考以下 C 程式的用途，以及在什麼場合用得到 (提示: 記憶體管理常式)，探討應用場合時，需要一併列出最小可編譯和運作的 C 程式碼。

   #+BEGIN_SRC c
     void *p;
     // ...
     ,*p = (*p) & ~1;
   #+END_SRC

** TODO Q4

   考慮以下 C 程式在 GNU/Linux 中，透過 linked list 來實作動態記憶體管理 (malloc 和 free)，虛擬記憶體的使用如下圖，初步的程式如下方，要注意到程式碼並不完整，也不能在多執行緒環境安全運用。
   請改寫 =malloc= 程式碼使其正確運作，並提供對應的 =free= 實作。

   [[file:images/NC8J0Hv.png]]

   #+BEGIN_SRC C
     #include <stddef.h>
     #include <unistd.h>
     #include <pthread.h>
     struct header_t {
	 size_t size;
	 unsigned is_free;
	 struct header_t *next;
     } *head, *tail;

     static struct header_t *
     get_free_block(size_t size) {
	 struct header_t *curr = head;
	 while (curr) {
	     if (curr->is_free && curr->size >= size) return curr;
	     curr = curr->next;
	 }
	 return NULL;
     }

     pthread_mutex_t global_malloc_lock;

     void *malloc(size_t size) {
	 size_t total_size;
	 void *block;
	 struct header_t *header;
	 if (!size) return NULL;
	 if ((header = get_free_block(size))) {
	     header->is_free = 0;
	     return ? /* FIXME: */
	 }

	 total_size = sizeof(struct header_t) + size;
	 if ((block = sbrk(total_size)) == (void *) -1)
	     return NULL;

	 header = block;
	 header->size = size;
	 header->is_free = 0;
	 header->next = NULL;
     //    ... /* FIXME: */
	 return ? /* FIXME: */
     }
   #+END_SRC
** TODO Q5

   假設下方 C 程式檔名為 =fork.c= ，在 GNU/Linux 上編譯得到名為 =fork= 的執行檔，我們可用 =./fork | wc -c= 計算輸出的 =-= 字元，請解釋程式行為和輸出的 =-= 字元數量的關聯。

   #+BEGIN_SRC C
     #include <stdio.h>
     #include <sys/types.h>
     #include <sys/wait.h>
     #include <unistd.h>

     int main() {
	 for (int i = 0; i < 3; i++) {
	     fork();
	     printf("-");
	}
	wait(NULL); wait(NULL); wait(NULL);
	return 0;
     }
   #+END_SRC